<html>
  <head>
	<script src='//unpkg.com/valine/dist/Valine.min.js'></script>
    <meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>社会智能：回顾 | slackmorning</title>
<link rel="shortcut icon" href="https://slackmorning.icu/favicon.ico?v=1589958629876">
<link href="https://cdn.jsdelivr.net/npm/remixicon@2.3.0/fonts/remixicon.css" rel="stylesheet">
<link rel="stylesheet" href="https://slackmorning.icu/styles/main.css">
<link rel="alternate" type="application/atom+xml" title="社会智能：回顾 | slackmorning - Atom Feed" href="https://slackmorning.icu/atom.xml">
<link rel="stylesheet" href="https://fonts.lug.ustc.edu.cn/css?family=Droid+Serif:400,700">



    <meta name="description" content="摸鱼笔记😇

知识表示

什么是知识表示？
知识表示是用计算机能够接受并进行处理的方式来表示人类的知识
知识表示的目的
通过知识的有效表示，使人工智能程序能够利用这些知识求解问题

人工智能所涉及的知识

事实
关于问题环境的一些客观事物..." />
    <meta name="keywords" content="社会智能" />
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.10.0/katex.min.css">
    <script src="https://cdn.bootcss.com/highlight.js/9.12.0/highlight.min.js"></script>
  </head>
  <body>
    <div class="main">
      <div class="main-content">
        <div class="site-header">
  <a href="https://slackmorning.icu">
  <img class="avatar" src="https://slackmorning.icu/images/avatar.png?v=1589958629876" alt="">
  </a>
  <h1 class="site-title">
    slackmorning
  </h1>
  <p class="site-description">
    🤤摸鱼/笔记
  </p>
  <div class="menu-container">
    
      
        <a href="/" class="menu">
          首页
        </a>
      
    
      
        <a href="/archives" class="menu">
          归档
        </a>
      
    
      
        <a href="/tags" class="menu">
          标签
        </a>
      
    
      
        <a href="/about" class="menu">
          关于
        </a>
      
    
      
        <a href="/friends" class="menu">
          朋友
        </a>
      
    
  </div>
  <div class="social-container">
    
      
        <a href="https://github.com/Opdoop" target="_blank">
          <i class="ri-github-line"></i>
        </a>
      
    
      
    
      
    
      
    
      
    
    
    <a href="https://space.bilibili.com/7456099" target="_blank">
      <i>
        <img src="https://slackmorning.icu/images/bilibili.png" alt="" style="width:18px;height:18px;">
      </i></a>
    
  </div>
</div>

        <div class="post-detail">
          <article class="post">
            <h2 class="post-title">
              社会智能：回顾
            </h2>
            <div class="post-info">
              <span>
                2020-05-09
              </span>
              <span>
                7 min read
              </span>
              
                <a href="https://slackmorning.icu/XFYQ0o8eT/" class="post-tag">
                  # 社会智能
                </a>
              
            </div>
            
              <img class="post-feature-image" src="https://slackmorning.icu/post-images/5MAjxI4HG.png" alt="">
            
            <div class="post-content-wrapper">
              <div class="post-content">
                <p>摸鱼笔记😇</p>
<!-- more -->
<h2 id="知识表示">知识表示</h2>
<ul>
<li>什么是知识表示？<br>
知识表示是用计算机能够接受并进行处理的方式来表示人类的知识</li>
<li>知识表示的目的<br>
通过知识的有效表示，使人工智能程序能够利用这些知识求解问题</li>
</ul>
<h2 id="人工智能所涉及的知识">人工智能所涉及的知识</h2>
<ul>
<li>事实<br>
关于问题环境的一些客观事物的知识，通常形式：“…是…”</li>
<li>规则<br>
关于事物之间因果关系的知识，通常形式：“如果…那么…”</li>
<li>控制知识<br>
关于做一件事的技巧性、策略性的知识</li>
<li>元知识<br>
关于知识的知识，有两种：包括说明知识和运用知识的元知识</li>
</ul>
<p><strong>ps</strong> ：控制知识和元知识内容上二者有重叠，但控制知识耦合在程序内，元知识为外部库</p>
<h2 id="如何衡量知识表示方法">如何衡量知识表示方法</h2>
<ul>
<li>知识表示的范围和程度（广度、精度）</li>
<li>是否适于计算机处理</li>
<li>是否适合推理</li>
<li>是否易于用户使用</li>
</ul>
<table>
<thead>
<tr>
<th>陈述性表示</th>
<th>过程性表示</th>
</tr>
</thead>
<tbody>
<tr>
<td>知识的静态描述</td>
<td>知识的动态描述</td>
</tr>
<tr>
<td>表示与推理分开处理</td>
<td>表示与推理相结合</td>
</tr>
<tr>
<td>较严格，模块性较好</td>
<td>不够严格，知识间有交互</td>
</tr>
<tr>
<td>有时效率较低</td>
<td>求解效率高</td>
</tr>
</tbody>
</table>
<h2 id="结构化知识表示方法">结构化知识表示方法</h2>
<p>随知识更称发展，属于符号注意智能观与知识工程表示观下。<br>
<img src="https://slackmorning.icu/post-images/1589017344514.png" alt="结构化知识表示方法" loading="lazy"></p>
<h2 id="语义网络">语义网络</h2>
<p>记忆是概念见的联系，通过记忆来进行概念间的推导，表示概念间的关系。</p>
<ul>
<li>结构<br>
采用有向图表示，也可以用二元组表示
<ul>
<li>有向图：<br>
结点：事物、概念、属性值、事件、情形等<br>
弧：节点1的属性或检点之间的关系；方向表示主次</li>
</ul>
</li>
<li>表示
<ol>
<li>结点的属性</li>
<li>结点间典型关系：
<ul>
<li>is-a: 个体对类、子类对类的隶属关系</li>
<li>part-of：全体对部分的包含关系<br>
<img src="https://slackmorning.icu/post-images/1589017802316.png" alt="语义网络" loading="lazy"></li>
</ul>
</li>
<li>event 结点：表示一个动作或事件</li>
<li>situation 结点：表示一个情形或状况</li>
<li>逻辑联结词和量词的表示</li>
</ol>
</li>
</ul>
<h3 id="语义网络的推理">语义网络的推理</h3>
<ul>
<li>匹配：语义网络知识库与待求解问题的语义网络模式</li>
<li>继承：隶属关系下的属性继承、直接继承等<br>
<img src="https://slackmorning.icu/post-images/1589017997188.png" alt="语义网络的推理" loading="lazy"></li>
</ul>
<h3 id="语义网络表示法的特点">语义网络表示法的特点</h3>
<ul>
<li>优点
<ul>
<li>直链、直观、结构化</li>
<li>联想性</li>
<li>推理效率较为高效</li>
</ul>
</li>
<li>主要弱点
<ul>
<li>缺乏严格的理论基础<br>
缺乏严格的形式定义；对于网络结构，缺乏明确的语义解释</li>
<li>继承推理的非有效性<br>
复杂情形下继承推理的冲突；非单调性、常识推理研究<br>
主要使用领域为：需要根据复杂分类知识进行推理的领域，需要表示事件、状况、性质、概念间关系的领域。</li>
</ul>
</li>
</ul>
<h2 id="框架表示法">框架表示法</h2>
<p>认为人脑中存在典型情景。在新情景下，根据粗略情况，填充框架内的值，最后再存储在记忆中。<br>
<img src="https://slackmorning.icu/post-images/1589018283305.png" alt="框架表示法" loading="lazy"></p>
<h3 id="框架表示下的推理">框架表示下的推理</h3>
<p>匹配和继承填槽方式：</p>
<ol>
<li>继承：下层框架继承上层框架的属性</li>
<li>默认：如果没有相反的证据，槽值取默认值</li>
<li>附加过程：
<ul>
<li>if needed 槽: 用于说明如何计算得到槽值</li>
<li>if added 槽: 用于说明填槽值时需要完成哪些操作</li>
</ul>
</li>
</ol>
<p>从框架库中寻找适合当前问题的最佳候选框架。</p>
<h3 id="框架表示法的特点">框架表示法的特点</h3>
<ul>
<li>优点：结构化知识、推理效率较高、陈述性与过程性表示结合</li>
<li>弱点：
<ul>
<li>严格性不足、继承推理的非有效性</li>
<li>许多实际情况与原型不符，对新的情况不易适应</li>
</ul>
</li>
</ul>
<table>
<thead>
<tr>
<th></th>
<th>产生式系统</th>
<th>框架系统</th>
</tr>
</thead>
<tbody>
<tr>
<td>知识表示单位</td>
<td>相互独立的规则</td>
<td>框架结构</td>
</tr>
<tr>
<td>推理机制</td>
<td>固定、与知识库分离</td>
<td>可变、与知识库成一体</td>
</tr>
<tr>
<td>知识库构建</td>
<td>较容易</td>
<td>困难</td>
</tr>
<tr>
<td>系统通用性</td>
<td>较低</td>
<td>高</td>
</tr>
<tr>
<td>应用问题领域</td>
<td>简单问题</td>
<td>复杂问题</td>
</tr>
<tr>
<td>用户程度</td>
<td>初学者</td>
<td>专家</td>
</tr>
</tbody>
</table>
<h2 id="逻辑表示法">逻辑表示法</h2>
<ul>
<li>
<p>逻辑法求解问题的一般步骤<br>
<img src="https://slackmorning.icu/post-images/1589018691472.png" alt="逻辑法求解问题的一般步骤" loading="lazy"></p>
</li>
<li>
<p>优点：自然性、严格性、模块性</p>
</li>
<li>
<p>弱点：难以表达结构性、多层次关联知识；推理低效性</p>
</li>
<li>
<p>应用问题：逻辑/规划/证明问题</p>
</li>
</ul>
<h2 id="产生式表示法">产生式表示法</h2>
<p>有与图灵机相当的表示能力，有心理学家认为人脑的表示为产生式表示法</p>
<ul>
<li>事实
<ul>
<li>使用三元组（对象, 属性, 值）或（关系, 对象1, 对象2）表示</li>
</ul>
</li>
<li>规则
<ul>
<li>采用“if &lt;前件&gt; then &lt;后件&gt;”的形式</li>
<li>规则可以加可信度，表示规则的不确定性</li>
</ul>
</li>
</ul>
<h3 id="产生式系统的结构">产生式系统的结构</h3>
<figure data-type="image" tabindex="1"><img src="https://slackmorning.icu/post-images/1589018947779.png" alt="产生式系统的结构" loading="lazy"></figure>
<ul>
<li>知识库
<ul>
<li>规则库：以产生式规则形式存放 领域知识的存储区</li>
<li>数据库：存放初始事实、中间结 果及最后结果的工作区</li>
</ul>
</li>
<li>推理机：包含推理方式和控制策略，工作过程：
<ol>
<li>数据库中的数据与规则库中的规则相匹配，得匹配规则集</li>
<li>从匹配规则集中选择一条规则作为使用规则（控制策略）</li>
<li>根据规则，执行相应的操作<br>
重复这个过程，直到满足结束条件。</li>
</ol>
</li>
</ul>
<h3 id="产生式系统的推理">产生式系统的推理</h3>
<ol>
<li>正向推理（数据驱动、自底向上方式）</li>
<li>反向推理（目标驱动、自顶向下方式）</li>
<li>双向推理（既自底向上又自顶向下）</li>
</ol>
<h3 id="产生式表示法的特点">产生式表示法的特点</h3>
<p>产生式表示格式固定，形式单一，规则间相互较为独立，使知识库的建立较为容易；同时知识库与推理机分离，易于对知识库进行增删、修改；推理方式单纯，对推理也容易作出解释；因此常作为建造知识系统的首选知识表示方法，尤其在一些较简单的知识系统中使用得最多。</p>
<ul>
<li>优点：自然性、模块性、有效性</li>
<li>弱点：
<ul>
<li>推理过程的低效率，容易引起组合爆炸</li>
<li>不能表达结构性的知识以及知识间的联系</li>
</ul>
</li>
</ul>
<p>应用于对知识表示比较松散的领域。</p>
<h2 id="知识表示观">知识表示观</h2>
<figure data-type="image" tabindex="2"><img src="https://slackmorning.icu/post-images/1589019188099.png" alt="知识表示观" loading="lazy"></figure>
<ul>
<li>知识表示：客观事物到推理内部的一种映射</li>
<li>应与问题领域的知识特性相吻合，以最大程度地减少失真</li>
</ul>
<h2 id="关于推理">关于推理</h2>
<p>推理：依据一定的原则从前提推出结论的过程，从逻辑上分为</p>
<ul>
<li>演绎推理：由一组前提必然地推导出某个结论的过程<br>
核心：三段论；保真性；没有增加新知识</li>
<li>归纳推理：以某个命题为前提，推出与其有归纳关系的其它命题的过程<br>
简单枚举法、类比法等；增加了新知识；不保真</li>
<li>溯因推理：解释观察到的一个结果的推理过程（用于产生解释）<br>
需要背景理论来构造并检查生成的解释；不保真</li>
</ul>
<h3 id="推理形式示例">推理形式示例</h3>
<figure data-type="image" tabindex="3"><img src="https://slackmorning.icu/post-images/1589019358249.png" alt="推理形式示例" loading="lazy"></figure>
<h3 id="经典与非经典逻辑推理">经典与非经典逻辑推理</h3>
<ul>
<li>经典逻辑推理<br>
标准逻辑下的演绎推理是人工智能最早采用的经典推理方法， 归结推理方法是其最重要的形式化方法</li>
<li>非经典逻辑与非经典推理<br>
<img src="https://slackmorning.icu/post-images/1589019433895.png" alt="非经典逻辑与非经典推理" loading="lazy"></li>
</ul>
<h3 id="基于知识的推理">基于知识的推理</h3>
<ul>
<li>基于知识的推理→演绎推理：确定、严格、一致</li>
<li>确定→不确定：不确定推理 (Approximate Reasoning)</li>
<li>基于模型的推理 (定性推理,Qualitative Reasoning)</li>
</ul>
					
              </div>
              <div class="toc-container">
                <ul class="markdownIt-TOC">
<li>
<ul>
<li><a href="#%E7%9F%A5%E8%AF%86%E8%A1%A8%E7%A4%BA">知识表示</a></li>
<li><a href="#%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD%E6%89%80%E6%B6%89%E5%8F%8A%E7%9A%84%E7%9F%A5%E8%AF%86">人工智能所涉及的知识</a></li>
<li><a href="#%E5%A6%82%E4%BD%95%E8%A1%A1%E9%87%8F%E7%9F%A5%E8%AF%86%E8%A1%A8%E7%A4%BA%E6%96%B9%E6%B3%95">如何衡量知识表示方法</a></li>
<li><a href="#%E7%BB%93%E6%9E%84%E5%8C%96%E7%9F%A5%E8%AF%86%E8%A1%A8%E7%A4%BA%E6%96%B9%E6%B3%95">结构化知识表示方法</a></li>
<li><a href="#%E8%AF%AD%E4%B9%89%E7%BD%91%E7%BB%9C">语义网络</a>
<ul>
<li><a href="#%E8%AF%AD%E4%B9%89%E7%BD%91%E7%BB%9C%E7%9A%84%E6%8E%A8%E7%90%86">语义网络的推理</a></li>
<li><a href="#%E8%AF%AD%E4%B9%89%E7%BD%91%E7%BB%9C%E8%A1%A8%E7%A4%BA%E6%B3%95%E7%9A%84%E7%89%B9%E7%82%B9">语义网络表示法的特点</a></li>
</ul>
</li>
<li><a href="#%E6%A1%86%E6%9E%B6%E8%A1%A8%E7%A4%BA%E6%B3%95">框架表示法</a>
<ul>
<li><a href="#%E6%A1%86%E6%9E%B6%E8%A1%A8%E7%A4%BA%E4%B8%8B%E7%9A%84%E6%8E%A8%E7%90%86">框架表示下的推理</a></li>
<li><a href="#%E6%A1%86%E6%9E%B6%E8%A1%A8%E7%A4%BA%E6%B3%95%E7%9A%84%E7%89%B9%E7%82%B9">框架表示法的特点</a></li>
</ul>
</li>
<li><a href="#%E9%80%BB%E8%BE%91%E8%A1%A8%E7%A4%BA%E6%B3%95">逻辑表示法</a></li>
<li><a href="#%E4%BA%A7%E7%94%9F%E5%BC%8F%E8%A1%A8%E7%A4%BA%E6%B3%95">产生式表示法</a>
<ul>
<li><a href="#%E4%BA%A7%E7%94%9F%E5%BC%8F%E7%B3%BB%E7%BB%9F%E7%9A%84%E7%BB%93%E6%9E%84">产生式系统的结构</a></li>
<li><a href="#%E4%BA%A7%E7%94%9F%E5%BC%8F%E7%B3%BB%E7%BB%9F%E7%9A%84%E6%8E%A8%E7%90%86">产生式系统的推理</a></li>
<li><a href="#%E4%BA%A7%E7%94%9F%E5%BC%8F%E8%A1%A8%E7%A4%BA%E6%B3%95%E7%9A%84%E7%89%B9%E7%82%B9">产生式表示法的特点</a></li>
</ul>
</li>
<li><a href="#%E7%9F%A5%E8%AF%86%E8%A1%A8%E7%A4%BA%E8%A7%82">知识表示观</a></li>
<li><a href="#%E5%85%B3%E4%BA%8E%E6%8E%A8%E7%90%86">关于推理</a>
<ul>
<li><a href="#%E6%8E%A8%E7%90%86%E5%BD%A2%E5%BC%8F%E7%A4%BA%E4%BE%8B">推理形式示例</a></li>
<li><a href="#%E7%BB%8F%E5%85%B8%E4%B8%8E%E9%9D%9E%E7%BB%8F%E5%85%B8%E9%80%BB%E8%BE%91%E6%8E%A8%E7%90%86">经典与非经典逻辑推理</a></li>
<li><a href="#%E5%9F%BA%E4%BA%8E%E7%9F%A5%E8%AF%86%E7%9A%84%E6%8E%A8%E7%90%86">基于知识的推理</a></li>
</ul>
</li>
</ul>
</li>
</ul>

              </div>
            </div>
          </article>
        </div>

        
          <div class="next-post">
            <div class="next">下一篇</div>
            <a href="https://slackmorning.icu/rNsLj_-Oh/">
              <h3 class="post-title">
                社会智能：概述
              </h3>
            </a>
          </div>
        

		<div id="vcomments"></div>
		<script>
			new Valine({
				el: '#vcomments',
				appId: 'GsWUMl5T5cUvWJRYiLKuUMYC-MdYXbMMI',
				appKey: '7EIbaqseUiGj33I0I1z93nSG',
				avatar:'hide',
				placeholder: '若有天我不复勇往 能否坚持走完这一场 踏遍万水千山总有一地故乡'
			})
		</script>

        

        <div class="site-footer">
  © 2020 by slackmorning. All rights reserved.
  <a class="rss" href="https://slackmorning.icu/atom.xml" target="_blank">
    <i class="ri-rss-line"></i> RSS
  </a>
</div>

      </div>
    </div>

    <script>
      hljs.initHighlightingOnLoad()

      let mainNavLinks = document.querySelectorAll(".markdownIt-TOC a");

      // This should probably be throttled.
      // Especially because it triggers during smooth scrolling.
      // https://lodash.com/docs/4.17.10#throttle
      // You could do like...
      // window.addEventListener("scroll", () => {
      //    _.throttle(doThatStuff, 100);
      // });
      // Only not doing it here to keep this Pen dependency-free.

      window.addEventListener("scroll", event => {
        let fromTop = window.scrollY;

        mainNavLinks.forEach((link, index) => {
          let section = document.getElementById(decodeURI(link.hash).substring(1));
          let nextSection = null
          if (mainNavLinks[index + 1]) {
            nextSection = document.getElementById(decodeURI(mainNavLinks[index + 1].hash).substring(1));
          }
          if (section.offsetTop <= fromTop) {
            if (nextSection) {
              if (nextSection.offsetTop > fromTop) {
                link.classList.add("current");
              } else {
                link.classList.remove("current");
              }
            } else {
              link.classList.add("current");
            }
          } else {
            link.classList.remove("current");
          }
        });
      });

    </script>
  </body>
</html>
